Go has addressable expressions.  Variables, field selectors on addressable structs, and indexes into slices or addressable arrays have type `T` but their addresses can be taken.  One could say they have _available_ type `*T`, whereas non-addressable expressions of type `T` have _available_ type `T`.

Flux dispenses with the notion of addressability.  An addressable expression of type `T` in Go simply has type `*T` in Flux.  In Flux, for example:  Indexing a `[]T` returns a `*T`; and selecting a field of type `T` from a pointer-to-struct returns a `*T`.

Consider if type `T` has a method `f` with pointer receiver:  `func (t *T) f() { ... }`  In Go, an addressable expression of type `T` is automatically addressed when calling such a pointer method on it.  In Flux, such an expression has type `*T`, so no automatic addressing is needed.  However, if the result is instead used in a context that calls for a `T` then it is automatically dereferenced.  For example, although an index into `[]int` returns `*int`, the result can be used in an addition (`+`) expression without any further ado.

One possible drawback of treating addressability in this way is the profusion of pointer types that it causes:  Many nodes have output of type `*T` when we are often only interested in `T`.  It doesn't cause any extra work on the programmer's part -- such pointers are automatically dereferenced as necessary -- but could be considered an eyesore.  However, I think the benefit of seeing the _available_ type explicitly rather than having to infer it by considering its source outweighs this possible drawback.

A possible issue arises when comparing certain values with untyped nil.  In particular, if a value has type `*T` where `T` itself can be compared to nil (i.e., if `T` is a slice, map, func, etc) then the comparison might be considered ambiguous:  Are we checking if the value is a nil pointer or is it being automatically dereferenced and we are checking whether it points to a nil slice, map, etc?  Here, the origin of the value is important:  If it was the result of one of Go's addressable expressions then the pointer cannot be nil so the comparison must of the latter sort; otherwise it is a pointer comparison.  It involves a bit more work on Flux's part -- looking back to the originating nodes -- but I believe it can be properly accounted for.